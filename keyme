#########################################################
## Keys
#########################################################

_keysToLoadHelp () {
echo '

Error:  Missing KEYME_KEYS_TO_LOAD Environment

Syntax:
  $last_pass_id<space>$friendly_name_on_your_disk

Example:

export KEYME_KEYS_TO_LOAD="
4318234233850238648 example1
8764128140835055732 example2
5866756601936395183 id_rsa
"
'

}

_lastPassUserHelp () {
echo '

Error:  Missing LASTPASS_USER Environment

Syntax:
  export LASTPASS_USER="jdoe@email.com"

You should probably set this in your bashrc or zshrc
'
}

_purgeIfEmpty () {
  CHECK=$(cat $1)
  if [ -z "${CHECK}" ]; then
    echo Removing Empty: $1
    rm "$1"
  fi
}

_chmod () {
  [ -f "$2" ] && chmod $1 "$2"
}

# Validate that a directory is on an ephemeral filesystem and has safe permissions.
# Returns 0 if safe, 1 if not. Prints error to stderr on failure.
_keyme_validate_dir () {
  local dir="$1"

  if [[ "$(uname)" == "Darwin" ]]; then
    # macOS: TMPDIR must be under /var/folders/ (OS-managed, cleaned on reboot)
    if [[ "$dir" != /var/folders/* && "$dir" != /private/var/folders/* ]]; then
      echo "Error: directory '$dir' is not under macOS-managed /var/folders/." >&2
      echo "  Keys would persist on disk across reboots." >&2
      return 1
    fi
  else
    # Linux: must be on tmpfs
    local fstype
    fstype=$(findmnt -n -o FSTYPE --target "$dir" 2>/dev/null) || fstype=""
    if [[ "$fstype" != "tmpfs" ]]; then
      echo "Error: '$dir' is not on tmpfs (found: '${fstype:-unknown}')." >&2
      echo "  Keys would persist on disk across reboots." >&2
      return 1
    fi
  fi

  # Verify ownership: must be owned by current user
  local dir_owner
  if [[ "$(uname)" == "Darwin" ]]; then
    dir_owner=$(stat -f %Su "$dir" 2>/dev/null)
  else
    dir_owner=$(stat -c %U "$dir" 2>/dev/null)
  fi
  if [[ "$dir_owner" != "$(id -un)" ]]; then
    echo "Error: '$dir' is owned by '$dir_owner', expected '$(id -un)'." >&2
    return 1
  fi

  # Verify not world-writable
  local perms
  if [[ "$(uname)" == "Darwin" ]]; then
    perms=$(stat -f %Lp "$dir" 2>/dev/null)
  else
    perms=$(stat -c %a "$dir" 2>/dev/null)
  fi
  local other_bits="${perms: -1}"
  if [[ "$other_bits" =~ [2367] ]]; then
    echo "Error: '$dir' is world-writable (mode: $perms). sshd StrictModes will reject this." >&2
    return 1
  fi

  return 0
}

# Find a safe, ephemeral directory for SSH key storage.
# Validates filesystem type and permissions BEFORE returning.
# Prints the directory path on success, error on failure.
_keyme_find_ephemeral_dir () {
  local candidate=""

  if [[ "$(uname)" == "Darwin" ]]; then
    candidate="${TMPDIR:-}"
    if [[ -z "$candidate" ]]; then
      echo "Error: TMPDIR is not set on macOS." >&2
      return 1
    fi
    # Validate before using
    _keyme_validate_dir "$candidate" || return 1

  else
    # Linux: prefer XDG_RUNTIME_DIR, fall back to /run/user/<uid>
    candidate="${XDG_RUNTIME_DIR:-}"

    if [[ -n "$candidate" ]]; then
      # XDG_RUNTIME_DIR is set — validate it
      _keyme_validate_dir "$candidate" || return 1
    else
      # XDG_RUNTIME_DIR not set — try /run/user/<uid>
      # First verify /run is tmpfs BEFORE creating anything
      local fstype
      fstype=$(findmnt -n -o FSTYPE --target /run 2>/dev/null) || fstype=""
      if [[ "$fstype" != "tmpfs" ]]; then
        echo "Error: /run is not tmpfs (found: '${fstype:-unknown}'). No safe ephemeral storage available." >&2
        return 1
      fi

      local uid
      uid=$(id -u)
      candidate="/run/user/$uid"

      # Create the runtime dir if it doesn't exist (requires sudo)
      if [[ ! -d "$candidate" ]]; then
        echo "Creating $candidate (XDG_RUNTIME_DIR not set)..." >&2
        sudo mkdir -p "$candidate" || { echo "Error: failed to create $candidate" >&2; return 1; }
        sudo chown "$(id -un):$(id -gn)" "$candidate" || { echo "Error: failed to chown $candidate" >&2; return 1; }
        sudo chmod 700 "$candidate" || { echo "Error: failed to chmod $candidate" >&2; return 1; }
      fi

      # Validate the created/existing dir
      _keyme_validate_dir "$candidate" || return 1
      export XDG_RUNTIME_DIR="$candidate"
    fi
  fi

  echo "${candidate%/}"
}

TMP_SSH_KEY_DIR=""
add_key () {
  echo Installing Key: $2
  local item=$(_bwGetItemFromCache "$1")
  echo "$item" | jq -r '.notes' > "${TMP_SSH_KEY_DIR}/$2"
  echo "$item" | jq -r '.fields[] | select(.name=="public") | .value' > "${TMP_SSH_KEY_DIR}/$2.pub" 2> /dev/null
  _purgeIfEmpty "${TMP_SSH_KEY_DIR}/$2"
  _purgeIfEmpty "${TMP_SSH_KEY_DIR}/$2.pub"
  _chmod 400 "${TMP_SSH_KEY_DIR}/$2"
  _chmod 400 "${TMP_SSH_KEY_DIR}/$2.pub"
}

keyme () {
  [ -z "${KEYME_KEYS_TO_LOAD}" ] && _keysToLoadHelp && return

  # Find and validate ephemeral storage BEFORE doing anything
  local ephemeral_base
  ephemeral_base=$(_keyme_find_ephemeral_dir) || return 1
  TMP_SSH_KEY_DIR="${ephemeral_base}/.ssh"

  _bwLogout
  echo "Bitwarden Login..."
  echo "Populating Bitwarden cache..."
  _bwEnsureCache > /dev/null
  echo Purging "${TMP_SSH_KEY_DIR}"
  [ -d "${TMP_SSH_KEY_DIR}" ] && rm -rf "${TMP_SSH_KEY_DIR}"
  echo Making tmp dir "${TMP_SSH_KEY_DIR}"...
  mkdir -p "${TMP_SSH_KEY_DIR}" 2> /dev/null
  chown $USER:$USER "${TMP_SSH_KEY_DIR}"
  chmod 700 "${TMP_SSH_KEY_DIR}"
  echo Purging "${HOME}/.ssh"
  [ -d $HOME/.ssh ] && rm -rf $HOME/.ssh
  ln -s "${TMP_SSH_KEY_DIR}" "${HOME}/.ssh"
  IFS=$'\n'
  for key_and_name in $(echo "${KEYME_KEYS_TO_LOAD}"); do
    local id=$(echo $key_and_name | awk '{print $1}')
    local name=$(echo $key_and_name | awk '{print $2}')
    add_key "${id}" "${name}"
  done

  # Build authorized_keys from loaded public keys
  if ls "${TMP_SSH_KEY_DIR}"/*.pub 1>/dev/null 2>&1; then
    cat "${TMP_SSH_KEY_DIR}"/*.pub > "${TMP_SSH_KEY_DIR}/authorized_keys" 2>/dev/null
    chmod 600 "${TMP_SSH_KEY_DIR}/authorized_keys"
    echo "authorized_keys built from loaded public keys"
  fi

  # Copy keys to Windows .ssh/ if running in WSL2 (VS Code uses Windows SSH)
  if [[ -d "/mnt/c" ]]; then
    local win_home
    win_home=$(wslpath "$(cmd.exe /C 'echo %USERPROFILE%' 2>/dev/null | tr -d '\r')" 2>/dev/null) || true
    if [[ -n "$win_home" && -d "$win_home" ]]; then
      local win_ssh="$win_home/.ssh"
      mkdir -p "$win_ssh" 2>/dev/null
      cp "${TMP_SSH_KEY_DIR}"/* "$win_ssh/" 2>/dev/null || true
      echo "SSH keys copied to Windows: $win_ssh"
    fi
  fi

  # Clean up cache unless persistence is enabled
  _bwCleanupCache
}

agentme () {
  sudo killall ssh-agent
  eval `ssh-agent`
  ssh-add "${HOME}/.ssh/"* \
    1> /dev/null \
    2> /dev/null
}
