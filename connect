#!/usr/bin/env bash
#############################################################################
# Dynamically Connect to AWS Resources
#############################################################################

# The request from amazon
INSTANCES_JSON="$HOME/run/ec2-instances.json"
# The formatting takes a bit so lets cache that too
INSTANCES_CACHE="$HOME/run/ec2-instances.cache"

function _loggedIntoAwsCli() {
  aws sts get-caller-identity > /dev/null 2> /dev/null
}

function _getInstancesTable() {
  local search="$1"

  # Skip all this if we already have the cache
  if [ ! -f "$INSTANCES_JSON" ]; then
    ! _loggedIntoAwsCli && echo "Not logged into AWS CLI" && return
    echo "Caching All EC2 Instance Info..."
    aws --region us-east-1 ec2 describe-instances > "$INSTANCES_JSON"
  fi

  if [ ! -f "$INSTANCES_CACHE" ]; then
    echo "Formatting for Search (Takes a bit the first time)..."
    # Using ^ as a delim since | is used a lot in practice
    # The below acts as a 'header'
    printf -v OUTPUT 'InstanceId^Name^PrivateIp^PublicIp'

    # Now lets make it fzf friendly
    for instance_id in $(jq -r '.Reservations[].Instances[].InstanceId' "$INSTANCES_JSON"); do
      INSTANCE=$(jq ".Reservations[].Instances[] | select(.InstanceId == \"$instance_id\")" "$INSTANCES_JSON")
      # Not all instances will have a name so we set a default
      NAME=$(echo "$INSTANCE" | jq -r '.Tags[] | select(.Key == "Name") | .Value')
      [ -z "$NAME" ] && NAME="Not Set"
      # The rest of this is normal
      INSTANCE_ID=$(echo "$INSTANCE" | jq -r '.InstanceId')
      PUBLIC_IP_ADDRESS=$(echo "$INSTANCE" | jq -r '.PublicIpAddress')
      PRIVATE_IP_ADDRESS=$(echo "$INSTANCE" | jq -r '.PrivateIpAddress')
      printf -v OUTPUT "$OUTPUT"'\n'"$INSTANCE_ID^$NAME^$PRIVATE_IP_ADDRESS^$PUBLIC_IP_ADDRESS"
    done

    # And remember our work for next time
    echo "$OUTPUT" > "$INSTANCES_CACHE"
  else
    OUTPUT=$(cat "$INSTANCES_CACHE")
  fi

  INSTANCES_TABLE=$(echo "$OUTPUT" | column -s'^' -t)
}


function _ssh_into() {
  local ip="$1"
  echo "Connecting to ${1}"
  for user in admiral ubuntu captain ec2-user; do
    echo "Trying: ssh ${user}@${ip}"
    if ssh -o ConnectTimeout=3 "${user}@${ip}" echo 2> /dev/null; then
      ssh "${user}@${ip}"
      return
    fi
  done

  # Couldn't connect
  false
}



function con() {
  local search="$1"
  if _getInstancesTable "$search" && [ -n "$INSTANCES_TABLE" ]; then
    unset THE_LIST
    unset SELECTED_INSTANCES
    unset SELECTED_INSTANCE
    SELECTED_INSTANCES=$(echo "$INSTANCES_TABLE" | fzf --layout=reverse --header-lines=1 ${search:+"-q $search"})

    if [ $? -gt 0 ]; then
      echo "User cancelled"
      return
    fi

    OLD="$IFS"
    IFS=$'\n'
    for SELECTED_INSTANCE in $(echo "$SELECTED_INSTANCES"); do
      INSTANCE_ID=$(echo "$SELECTED_INSTANCE" | awk '{print $1}')
      PRIVATE_IP=$(echo "$SELECTED_INSTANCE" | perl -pe 's|.*?([\.\d]{1,})\s+([\.\dnul]{1,})$|$1|')
      PUBLIC_IP=$(echo "$SELECTED_INSTANCE" | perl -pe 's|.*?([\.\d]{1,})\s+([\.\dnul]{1,})$|$2|')

      THE_LIST="$PRIVATE_IP $THE_LIST"
    done

    if [ $(echo "$SELECTED_INSTANCES" | wc -l) -gt 1 ]; then
      eval connect_to_all_machines $THE_LIST
      return
    fi

    # We'll just use the fact that this is empty to skip trying it
    [ "$PUBLIC_IP" = "null" ] && PUBLIC_IP=""

    echo "Trying: aws --region us-east-1 ssm start-session --target $INSTANCE_ID"
    [ -n "$INSTANCE_ID" ] && aws --region us-east-1 ssm start-session --target "$INSTANCE_ID" && return

    # Basically, if ssh doesn't work we'll try ssm
    for the_ip in $PRIVATE_IP $PUBLIC_IP; do
      _ssh_into "$the_ip" && return
    done

  fi
}

function con_refresh() {
  rm "${INSTANCES_JSON}"
  rm "${INSTANCES_CACHE}"
  con "$@"
}
